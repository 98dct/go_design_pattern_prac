
代码设计
1.可维护性：添加代码、修改代码不会引起线上bug
2.可读性：团队成员都能很好的读懂
3.可扩展性：预留了扩展的地方，便于扩展，不影响原来的主逻辑
4.灵活性：包含上述几个特征
5.简洁性
6.可复用性
7.可测试性

一、面向对象
我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。
它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点
面向对象分析：搞清楚做什么
面向对象设计：搞清楚怎么做
面向对象编程：就是将类或者对象作为组织代码的基本单元，并将封装、继承、抽象、多态这几个特性作为代码设计和实现的基石

1.封装：就是访问权限控制，go中就是结构体的字段和方法，字段和方法的首字母大写的话，结构体对象的字段和方法在包内和包外都可以访问，小写的话，对象的字段和方法只能在包内访问
生产中能小写的字段和方法，要尽可能小写，只给包外暴露必要的字段和方法权限
2.抽象：go中通过接口来暴漏方法，隐藏了内部的实现细节，调用方只需要关注，方法的作用，入参和出参即可
3.继承：主要是为了代码复用，go中使用组合来实现类似的继承效果，在一个结构体中嵌入另一个结构体即拥有了这个结构体的全部字段和方法，实现了代码复用，不要重写
4.多态：go中多态和抽象都是通过接口来实现的，一个接口（resource接口）定义了一些公共的方法（creat,update,destroy等），被一些结构体实现这些方法，这个过程中，接口就是抽象了一些公共的行为，
实现了这些方法的结构体，就是这个接口的多种形态，在函数传参时，通过接口类型作为入参，就可以支持多种结构体实现
go中的编译时多态: 范型  函数参数支持多种类型，但是编译时就确定了具体类型是哪一个
go中的运行时多态: 接口与实现  可以给接口类型传递不同的实现，代码形式上为接口类型调用接口的方法，运行时会动态调用实现的方法

go中定义一个结构体后应该通过它的方法暴漏功能，而不应该让用户直接修改结构体的字段内容
基于接口而非实现编程， 也是基于抽象编程而非实现编程
1.接口函数命名不能包含具体实现细节。接口只是说明做什么，不包含怎么做。设计更加通用的接口
2.封装具体的实现细节
3.为实现类定义统一的抽象接口

抽象意识、封装意识、接口意识
实际的目的是为少写代码，需求变化时少改动代码

继承：A is B     B是A的父类
组合：A has B    A有B这个属性

go中使用接口加组合实现功能扩展

接口是一组协议或者约定，是功能提供者给使用者的一个功能列表
越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。
好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对

基于贫血模型的MVC三层架构：
一些结构体只包含数据，不包含方法（即业务逻辑），数据与操作进行了分离，破坏了面向对象的封装特性（即没有对数据实现访问保护控制功能，也就是对数据的操作入口、管理方法）
基于充血模型的DDD(领域驱动设计)开发模式:
轻service重domain、适合大型复杂的项目
充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。
在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。
基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。
比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作
充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。
业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。
二、设计原则：
SRP单一职责原则：
一个结构体只承担一个事情，不要涉及大而全的类，设计粒度小，功能单一的类，
单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性

OCP开闭原则：对扩展开放，对修改关闭 大部分设计模式都是为了解决代码的扩展性而设计的
大致意思：添加一个功能，应该是在已有代码上扩展代码（新增模块、类、方法），而不是修改已有代码（模块、类、方法）
开闭原则讲的是代码的扩展性问题，我们写代码要时刻具备扩展意识、抽象意识、封装意识
写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，
事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。
当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。
怎样预留扩展点呢？
如果是业务导向系统，要对业务足够了解，识别出当下，以及未来可能支持的功能和需求
如果是业务无关的(框架、组件、类库)，要了解他们会被如何使用，未来打算添加哪些功能，使用者未来会有哪些需求

LSP里氏替换原则：子类型能够替换它们的基类型
ISP接口隔离原则: 抽象不持有特定逻辑，应持有实现的公有逻辑
DIP依赖倒置原则：底层不能互相依赖，应同时依赖抽象
DRY原则：不做重复的事，不写重复类似的代码
KISS原则：keep it simple，尽量简单的代码，让代码更容易被别人理解
YANGNI原则：you ain't gonna need it，只着眼必需的功能，不添加认为可能需要的功能
LOD原则：类应减少被外界直接访问的机会，类与类之间避免直接通信

不要只关心设计与实现，前期的需求分析同样重要

编写代码的规范：
一、需求分析：输出详细需求文档或者需求描述
例如：接口鉴权这个案例
需求描述如下：
1.调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。
2.微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。
3.微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。
4.如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配。如果一致，则鉴权成功，允许接口调用；否则就拒绝接口调用。
二、面向对象设计：输出结构体、包含的属性和提供的方法
三、面向对象编程：编写具体的实现逻辑，迭代、优化和调试等等

三、设计模式
创建型模式：
常用：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式
不常用：原型模式

结构型：
常用的：代理模式、桥接模式、装饰器模式、适配器模式
不常用：门面模式、组合模式、享元模式

行为型：
常用：观察者模式、模版模式、策略模式、职责链模式、迭代器模式、状态模式
不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式

四、编程规范
五、代码重构